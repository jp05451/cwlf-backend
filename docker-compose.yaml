version: '3.8'
services:
  app:
    # build: 告訴 Docker Compose 不要去網路上下載 image，
    # 而是根據 ./app 資料夾裡的 Dockerfile 來「自己建立」一個 image
    build: ./app
    container_name: cwolf-app-compose
    ports:
      # 將我們電腦的 3000 port 連接到容器的 3000 port
      - "3000:3000"
    environment:
      # 這裡就是魔法發生的地方！我們把連線資訊當作環境變數傳進去。
      # 注意：host 的值是「服務名稱」，而不是 localhost！
      - MYSQL_HOST=mysql_db
      - MYSQL_USER=root
      - MYSQL_ROOT_PASSWORD=asdfasdf
      - MYSQL_DATABASE=mysql # 我們可以先連到預設的 mysql 資料庫測試
      - RABBITMQ_HOST=rabbitmq
      - RABBITMQ_DEFAULT_USER=guest
      - RABBITMQ_DEFAULT_PASS=guest
    # depends_on: 確保在啟動 app 之前，先啟動 mysql_db 和 rabbitmq
    # 這能解決大部分啟動順序問題。
    depends_on:
      - mysql_db
      - rabbitmq

  # 這是你原本的資料庫服務
  mysql_db:
    # 教授的建議：固定版本號更穩定，避免 future 最新版造成問題
    image: mysql:9.4.0
    container_name: mysql-compose
    environment:
      MYSQL_ROOT_PASSWORD: asdfasdf
    ports:
      - "3306:3306"
    volumes:
      # 使用 Docker 管理的 "named volume"，而不是直接綁定目錄
      - mysql-data:/var/lib/mysql

  # 這是我們新增的 RabbitMQ 服務
  rabbitmq:
    image: rabbitmq:3-management
    container_name: rabbitmq-compose
    ports:
      # 5672 是 RabbitMQ 的主要通訊埠 (給程式用的)
      - "5672:5672"
      # 15672 是 RabbitMQ 管理介面的通訊埠 (給你看的)
      - "15672:15672"
    environment:
      # 這是管理介面的預設登入帳號密碼，你可以修改它
      - RABBITMQ_DEFAULT_USER=guest
      - RABBITMQ_DEFAULT_PASS=guest
    volumes:
      # 同樣使用 named volume 來保存 RabbitMQ 的資料
      - rabbitmq-data:/var/lib/rabbitmq

# 在這裡統一宣告我們要使用的 "named volumes"
volumes:
  mysql-data:
  rabbitmq-data:
